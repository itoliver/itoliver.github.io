<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oliver Blog</title>
  
  <subtitle>To Be a Batter Me</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ippai.top/"/>
  <updated>2018-04-09T04:51:57.888Z</updated>
  <id>http://ippai.top/</id>
  
  <author>
    <name>Oliver</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker-nginx-php部署</title>
    <link href="http://ippai.top/2018/04/09/docker-nginx-php%E9%83%A8%E7%BD%B2/"/>
    <id>http://ippai.top/2018/04/09/docker-nginx-php部署/</id>
    <published>2018-04-09T04:38:29.000Z</published>
    <updated>2018-04-09T04:51:57.888Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>nginx是web服务器常用的架构,是一个高性能的HTTP和反向代理服务器,也是一个IMAP/POP3/SMTP服务器。<br><a id="more"></a><br>服务器环境<br>nignx:基于docker最新版nginx<br>php:7.1.5</p><h1 id="1-拉取nginx和php-fpm镜像"><a href="#1-拉取nginx和php-fpm镜像" class="headerlink" title="1.拉取nginx和php-fpm镜像"></a>1.拉取nginx和php-fpm镜像</h1><pre><code>docker pull nginx</code></pre><p>docker pull php:7.1.5-fpm #自定义版本</p><pre><code>docker pull bitnami/php-fpm</code></pre><h1 id="2-创建nginx数据目录"><a href="#2-创建nginx数据目录" class="headerlink" title="2.创建nginx数据目录"></a>2.创建nginx数据目录</h1><pre><code>mkdir -p /opt/nginx/{conf,conf.d,html,log}mkdir -p /opt/php/conf</code></pre><h1 id="3-创建nginx-default-conf-此配置是支持go语言的反向代理"><a href="#3-创建nginx-default-conf-此配置是支持go语言的反向代理" class="headerlink" title="3.创建nginx default.conf,此配置是支持go语言的反向代理"></a>3.创建nginx default.conf,此配置是支持go语言的反向代理</h1><pre><code>cat /opt/nginx/conf.d/default.conf &lt;&lt; EOFmap $http_upgrade $connection_upgrade {        default upgrade;        &#39;&#39;      close;}upstream gameweb {        ip_hash;        server 192.168.1.14:3001 weight=2;        server 192.168.1.14:3002;}server{    listen 3003;    server_name master.localhost.com;    error_log /var/log/nginx/gameweb_error.log debug;    access_log /var/log/nginx/gameweb_access.log;location / {        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection $connection_upgrade;        proxy_pass_header Server;        proxy_set_header Host $http_host;        proxy_redirect off;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Scheme $scheme;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Nginx-Proxy true;        proxy_pass http://gameweb;        add_header Access-Control-Allow-Origin *;        add_header Access-Control-Allow-Credentials true;        add_header Access-Control-Allow-Headers Content-Type,Accept;        add_header Access-Control-Allow-Methods GET;    }}server {        listen       80 default_server;        server_name  _;        root         /usr/share/nginx/html;        location / {            index  index.html index.htm index.php;            autoindex  off;        }        location ~ \.php(.*)$ {            root           /usr/share/nginx/html/;            fastcgi_pass   php:9000;            fastcgi_index  index.php;            fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;            fastcgi_param  PATH_INFO  $fastcgi_path_info;            fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;            include        fastcgi_params;        }}EOF</code></pre><h1 id="4-配置php测试文件"><a href="#4-配置php测试文件" class="headerlink" title="4.配置php测试文件"></a>4.配置php测试文件</h1><pre><code>tee /opt/nginx/html/index.php &lt;&lt;EOF&lt;?phpecho &quot;TEST PAGE&quot;?&gt;EOF# 5.启动php容器</code></pre><p>docker run -tid \<br>-p 9000:9000 \<br>–name php-fpm \<br>–restart=always \<br>–privileged=true \<br>-v /opt/php/conf/:/bitnami/php/conf/ \<br>-v /opt/nginx/html:/usr/share/nginx/html \<br>bitnami/php-fpm</p><pre><code># 6.启动nginx容器</code></pre><p>docker run -tid \<br>–name nginx \<br>–restart=always \<br>-p 80:80 \<br>–privileged=true \<br>-v /opt/nginx/conf.d:/etc/nginx/conf.d \<br>-v /opt/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \<br>-v /opt/nginx/html:/usr/share/nginx/html \<br>-v /opt/nginx/log:/var/log/nginx \<br>–link php-fpm:php \<br>nginx<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言&lt;br&gt;nginx是web服务器常用的架构,是一个高性能的HTTP和反向代理服务器,也是一个IMAP/POP3/SMTP服务器。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker-mariadb集群-主从同步</title>
    <link href="http://ippai.top/2018/04/09/docker-mariadb%E9%9B%86%E7%BE%A4-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    <id>http://ippai.top/2018/04/09/docker-mariadb集群-主从同步/</id>
    <published>2018-04-09T04:27:34.000Z</published>
    <updated>2018-04-09T04:37:36.068Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。<br><a id="more"></a></p><h1 id="修改mariadb-docker系统时间"><a href="#修改mariadb-docker系统时间" class="headerlink" title="修改mariadb docker系统时间"></a>修改mariadb docker系统时间</h1><pre><code>tzselectcp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></pre><h2 id="master部署"><a href="#master部署" class="headerlink" title="master部署"></a>master部署</h2><h1 id="1-创建mariadb数据配置文件"><a href="#1-创建mariadb数据配置文件" class="headerlink" title="1.创建mariadb数据配置文件"></a>1.创建mariadb数据配置文件</h1><pre><code>mkdir -p /opt/docker-mariadb/{data,conf.d,script}</code></pre><h1 id="2-拉取mairadb10-1-10镜像"><a href="#2-拉取mairadb10-1-10镜像" class="headerlink" title="2.拉取mairadb10.1.10镜像"></a>2.拉取mairadb10.1.10镜像</h1><pre><code>docker pull mariadb:10.1.10</code></pre><h1 id="3-创建mariadb配置文件"><a href="#3-创建mariadb配置文件" class="headerlink" title="3.创建mariadb配置文件"></a>3.创建mariadb配置文件</h1><pre><code>tee /opt/docker-mariadb/conf.d/my.cnf &lt;&lt;EOF[mysqld]datadir=/var/lib/mysqlsocket=/run/mysqld/mysqld.sockserver-id = 1log_bin=master-binrelay-log=relay-binexpire_logs_days = 30binlog_format=rowsync_binlog = 1#sync_master_info = 1default-storage-engine=INNODBinnodb_file_per_table = ON#innodb_flush_logs_at_trx_commit#innodb_support_xa = oncharacter-set-server=utf8mb4slow_query_log = 1long_query_time = 2log_output = &#39;TABLE&#39;[mysql]default-character-set=utf8mb4auto-rehash[mysqld_safe]log-error=/var/log/mysql.logpid-file=/run/mysqld/mysqld.pidEOF</code></pre><h1 id="4-创建运行脚本"><a href="#4-创建运行脚本" class="headerlink" title="4.创建运行脚本"></a>4.创建运行脚本</h1><pre><code>tee /opt/docker-mariadb/script/mariadb.sh&lt;&lt;EOF#!/bin/bashdocker run -tid \--restart=always \--name mariadb-master \-p 3307:3306 \-v /opt/docker-mariadb/data:/var/lib/mysql \-v /opt/docker-mariadb/conf.d:/etc/mysql/conf.d \-e MYSQL_ROOT_PASSWORD=123456 \mariadb:10.1.10</code></pre><p>查看docker容器运行状态</p><pre><code>docker ps -a</code></pre><h1 id="5-进入mariadb容器"><a href="#5-进入mariadb容器" class="headerlink" title="5.进入mariadb容器"></a>5.进入mariadb容器</h1><pre><code>docker exec -it mariadb-master bash</code></pre><h1 id="6-配置mysql-master用户授权"><a href="#6-配置mysql-master用户授权" class="headerlink" title="6.配置mysql master用户授权"></a>6.配置mysql master用户授权</h1><pre><code>mysql -uroot -pgrant replication slave,replication client on *.* to &#39;repluser&#39;@&#39;shangserver004&#39; identified by &#39;replpassword&#39;;flush privileges;show master status;</code></pre><h2 id="slave部署"><a href="#slave部署" class="headerlink" title="slave部署"></a>slave部署</h2><h1 id="1-创建mariadb数据配置文件-1"><a href="#1-创建mariadb数据配置文件-1" class="headerlink" title="1.创建mariadb数据配置文件"></a>1.创建mariadb数据配置文件</h1><pre><code>mkdir -p /opt/docker-mariadb/{data,conf.d,script}</code></pre><h1 id="2-拉取mairadb10-1-10镜像-1"><a href="#2-拉取mairadb10-1-10镜像-1" class="headerlink" title="2.拉取mairadb10.1.10镜像"></a>2.拉取mairadb10.1.10镜像</h1><pre><code>docker pull mariadb:10.1.10</code></pre><h1 id="3-创建mariadb配置文件-1"><a href="#3-创建mariadb配置文件-1" class="headerlink" title="3.创建mariadb配置文件"></a>3.创建mariadb配置文件</h1><pre><code>tee /opt/docker-mariadb/conf.d/my.cnf &lt;&lt;EOF[mysqld]datadir=/var/lib/mysqlsocket=/run/mysqld/mysqld.sockserver-id = 2#log_bin=slave-bin#binlog_format=rowrelay-log=relay-binexpire_logs_days = 30read-only = onsync_binlog = 1default-storage-engine=INNODB#sync_relay_log = 1#sync_relay_log_info = 1innodb_file_per_table = ONcharacter-set-server=utf8mb4slow_query_log = 1long_query_time = 2log_output = &#39;TABLE&#39;[mysql]default-character-set=utf8mb4auto-rehash[mysqld_safe]log-error=/var/log/mysql.logpid-file=/run/mysqld/mysqld.pidEOF</code></pre><h1 id="4-创建运行脚本-1"><a href="#4-创建运行脚本-1" class="headerlink" title="4.创建运行脚本"></a>4.创建运行脚本</h1><pre><code>tee /opt/docker-mariadb/script/mariadb.sh&lt;&lt;EOF#!/bin/bashdocker run -tid \--restart=always \--name mariadb-slave \-p 3307:3306 \-v /opt/docker-mariadb/data:/var/lib/mysql \-v /opt/docker-mariadb/conf.d:/etc/mysql/conf.d \-e MYSQL_ROOT_PASSWORD=123456 \mariadb:10.1.10EOF</code></pre><p>查看docker容器运行状态</p><pre><code>docker ps -a</code></pre><h1 id="5-进入mariadb容器-1"><a href="#5-进入mariadb容器-1" class="headerlink" title="5.进入mariadb容器"></a>5.进入mariadb容器</h1><pre><code>docker exec -it mariadb-slave bash</code></pre><h1 id="6-配置mysql-slave"><a href="#6-配置mysql-slave" class="headerlink" title="6.配置mysql slave"></a>6.配置mysql slave</h1><pre><code>mysql -uroot -p</code></pre><pre><code>change master tomaster_host=&#39;192.168.1.14&#39;,master_port=3307,master_user=&#39;repluser&#39;,master_password=&#39;replpassword&#39;,master_log_file=&#39;master-bin.000001&#39;,master_log_pos=674,master_connect_retry=5,master_heartbeat_period=2;</code></pre><pre><code>star slave;</code></pre><pre><code>show status slave;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言&lt;br&gt;MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://ippai.top/categories/Docker/"/>
    
    
      <category term="linux自动化运维" scheme="http://ippai.top/tags/linux%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://ippai.top/tags/docker/"/>
    
      <category term="mariadb" scheme="http://ippai.top/tags/mariadb/"/>
    
  </entry>
  
  <entry>
    <title>docker_swarm集群</title>
    <link href="http://ippai.top/2018/04/08/docker-swarm%E9%9B%86%E7%BE%A4/"/>
    <id>http://ippai.top/2018/04/08/docker-swarm集群/</id>
    <published>2018-04-08T03:17:05.000Z</published>
    <updated>2018-04-09T03:45:45.835Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>Swarm项目是Docker公司发布三剑客中的一员，用来提供容器集群服务，目的是更好的帮助用户管理多个Docker Engine，方便用户使用，像使用Docker Engine一样使用容器集群服务。这次分享内容从Swarm项目现状、Swarm社区现状和Swarm未来的一些规划三方面介绍Swarm，目的是能让大家对Swarm有个完整的认识，并且希望更多的人采用到Swarm项目中来。<br>此文主要是swarm docker集群部署，仅供参考<br><a id="more"></a></p><p>环境：centos7.2<br>192.168.1.14 master swarm-manager rethinkdb controller swarm-agent consul-s1 registrator consul-template(nginx)<br>192.168.1.15 slave-1 registrator swarm-agent consul-s2<br>192.168.1.16 slave-2 registrator swarm-agent consul-s3<br>docker-engine    17.05.0-ce</p><h2 id="一、搭建docker集群环境"><a href="#一、搭建docker集群环境" class="headerlink" title="一、搭建docker集群环境"></a>一、搭建docker集群环境</h2><h1 id="1、先检查是否安装旧版本docker"><a href="#1、先检查是否安装旧版本docker" class="headerlink" title="1、先检查是否安装旧版本docker"></a>1、先检查是否安装旧版本docker</h1><pre><code>rpm -qa|grep docker</code></pre><p>如果有就先卸载</p><pre><code>yum remove docker*</code></pre><h1 id="2、添加docker-repo安装源，写入文件"><a href="#2、添加docker-repo安装源，写入文件" class="headerlink" title="2、添加docker.repo安装源，写入文件"></a>2、添加docker.repo安装源，写入文件</h1><pre><code>tee /etc/yum.repos.d/docker.repo&lt;&lt;EOF[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/main/centos/7/enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpgEOF</code></pre><h1 id="3、安装docker"><a href="#3、安装docker" class="headerlink" title="3、安装docker"></a>3、安装docker</h1><pre><code>yum install docker-engine</code></pre><h1 id="4、配置防火墙"><a href="#4、配置防火墙" class="headerlink" title="4、配置防火墙"></a>4、配置防火墙</h1><pre><code>firewall-cmd --permanent --add-port={2375/tcp,3375/tcp,8500/tcp,8300/tcp,8301/tcp,8301/udp,8302/tcp,8302/udp,8400/tcp,8500/tcp,8600/tcp,8600/udp,8080/tcp,28015/tcp,29015/tcp}firewall-cmd --reloadfirewall-cmd --list-all</code></pre><h1 id="iptables内容（使用的iptables）"><a href="#iptables内容（使用的iptables）" class="headerlink" title="iptables内容（使用的iptables）"></a>iptables内容（使用的iptables）</h1><pre><code>*nat:PREROUTING ACCEPT [0:0]:INPUT ACCEPT [0:0]:OUTPUT ACCEPT [0:0]:POSTROUTING ACCEPT [0:0]:DOCKER - [0:0]-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER-A POSTROUTING -s 192.168.0.0/16 ! -o docker0 -j MASQUERADECOMMIT#*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]:DOCKER - [0:0]-A FORWARD -o docker0 -j DOCKER-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT-A FORWARD -i docker0 ! -o docker0 -j ACCEPT-A FORWARD -i docker0 -o docker0 -j ACCEPT-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 2375 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 3375 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8300 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8301 -j ACCEPT-A INPUT -p udp -m state --state NEW -m udp --dport 8301 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8302 -j ACCEPT-A INPUT -p udp -m state --state NEW -m udp --dport 8302 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8400 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8500 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8600 -j ACCEPT-A INPUT -p udp -m state --state NEW -m udp --dport 8600 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 28015 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 29015 -j ACCEPT#-A INPUT -j REJECT --reject-with icmp-host-prohibited#-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT</code></pre><h1 id="5、增加tcp监听端口-并配置docker加速"><a href="#5、增加tcp监听端口-并配置docker加速" class="headerlink" title="5、增加tcp监听端口,并配置docker加速"></a>5、增加tcp监听端口,并配置docker加速</h1><p>修改/lib/systemd/system/docker.service<br>daocloud加速</p><pre><code>sed -i &#39;s/ExecStart=.*/ExecStart=\/usr\/bin\/dockerd -H unix\:\/\/\/var\/run\/docker.sock -D -H tcp\:\/\/0.0.0.0\:2375 --registry-mirror=http\:\/\/a582cc4e.m.daocloud.io --live-restore/g&#39; /lib/systemd/system/docker.service</code></pre><p>私库</p><pre><code>sed -i &#39;s/ExecStart=.*/ExecStart=\/usr\/bin\/dockerd -H unix\:\/\/\/var\/run\/docker.sock -D -H tcp\:\/\/0.0.0.0\:2375 --registry-mirror=http\:\/\/a582cc4e.m.daocloud.io --insecure-registry 192.168.1.14\:5000 --live-restore/g&#39; /lib/systemd/system/docker.service</code></pre><p>阿里云加速</p><pre><code>sed -i &#39;s/ExecStart=.*/ExecStart=\/usr\/bin\/dockerd -H unix\:\/\/\/var\/run\/docker.sock -D -H tcp\:\/\/0.0.0.0\:2375 --registry-mirror=https\:\/\/0xl18ug0.mirror.aliyuncs.com --live-restore/g&#39; /lib/systemd/system/docker.service</code></pre><h1 id="6、重启docker"><a href="#6、重启docker" class="headerlink" title="6、重启docker"></a>6、重启docker</h1><pre><code>systemctl daemon-reloadsystemctl enable docker.servicesystemctl restart docker.serviceps -ef |grep docker  #能看到docker启动以及2375端口</code></pre><p>#7、安装pip以及docker api</p><pre><code>yum -y install epel-releaseyum -y install python-pippip install docker-py docker-compose</code></pre><h1 id="8、创建consul用户及组"><a href="#8、创建consul用户及组" class="headerlink" title="8、创建consul用户及组"></a>8、创建consul用户及组</h1><pre><code>groupadd -g 1005 consuluseradd -u 105 -g 1005 -s /bin/false consul</code></pre><h1 id="9、创建consul数据存储文件夹"><a href="#9、创建consul数据存储文件夹" class="headerlink" title="9、创建consul数据存储文件夹"></a>9、创建consul数据存储文件夹</h1><pre><code>mkdir -p /opt/consul/{data,conf}chown -R consul: /opt/consul</code></pre><h1 id="10、设置主机hosts，有多少台主机，就需要设置多少hosts"><a href="#10、设置主机hosts，有多少台主机，就需要设置多少hosts" class="headerlink" title="10、设置主机hosts，有多少台主机，就需要设置多少hosts"></a>10、设置主机hosts，有多少台主机，就需要设置多少hosts</h1><pre><code>vim /etc/hosts192.168.1.14    master.localhost.com192.168.1.15    slave1.localhost.com192.168.1.16    slave2.localhost.com</code></pre><h2 id="二、配置consul-cluster"><a href="#二、配置consul-cluster" class="headerlink" title="二、配置consul cluster"></a>二、配置consul cluster</h2><h1 id="1、拉取consul镜像"><a href="#1、拉取consul镜像" class="headerlink" title="1、拉取consul镜像"></a>1、拉取consul镜像</h1><pre><code>docker pull progrium/consul</code></pre><p>#提示：目录没有官方出consul镜像，以上consul镜像是官方推荐的第三方docker image</p><h1 id="2、启动consul-server-192-168-1-14"><a href="#2、启动consul-server-192-168-1-14" class="headerlink" title="2、启动consul server 192.168.1.14"></a>2、启动consul server 192.168.1.14</h1><pre><code>docker run -d \-p 8300:8300 \-p 8301:8301 \-p 8301:8301/udp \-p 8302:8302 \-p 8302:8302/udp \-p 8400:8400 \-p 8500:8500 \-p 8600:53 \-p 8600:53/udp \-v /opt/consul/data:/data \-h $HOSTNAME \--restart=always \--name=consul-s1 \progrium/consul \-server -bootstrap-expect=1 \-ui-dir=/ui \-client 0.0.0.0 \-advertise 192.168.1.14</code></pre><h1 id="3、启动consul-server-192-168-1-15"><a href="#3、启动consul-server-192-168-1-15" class="headerlink" title="3、启动consul server 192.168.1.15"></a>3、启动consul server 192.168.1.15</h1><pre><code>docker run -d \-p 8300:8300 \-p 8301:8301 \-p 8301:8301/udp \-p 8302:8302 \-p 8302:8302/udp \-p 8400:8400 \-p 8500:8500 \-p 8600:53 \-p 8600:53/udp \-v /opt/consul/data:/data \-h consul-s2 \--restart=always \--name=consul-s2 \progrium/consul \-server \-ui-dir=/ui \-client 0.0.0.0 \-advertise 192.168.1.15 -join 192.168.1.14</code></pre><h1 id="4、启动consul-client-192-168-1-16"><a href="#4、启动consul-client-192-168-1-16" class="headerlink" title="4、启动consul client 192.168.1.16"></a>4、启动consul client 192.168.1.16</h1><pre><code>docker run -d \-p 8300:8300 \-p 8301:8301 \-p 8301:8301/udp \-p 8302:8302 \-p 8302:8302/udp \-p 8400:8400 \-p 8500:8500 \-p 8600:53 \-p 8600:53/udp \-v /opt/consul/data:/data \-h consul-c1 \--restart=always \--name=consul-c1 \progrium/consul \-advertise 192.168.1.16 -join 192.168.1.14</code></pre><h2 id="三、registrator状态获取"><a href="#三、registrator状态获取" class="headerlink" title="三、registrator状态获取"></a>三、registrator状态获取</h2><p>依次启动</p><pre><code>docker run -d \--restart=always \--name=registrator \--net=host \-v /var/run/docker.sock:/tmp/docker.sock \gliderlabs/registrator \-ip 192.168.1.14 \consul://192.168.1.14:8500</code></pre><pre><code>docker run -d \--restart=always \--name=registrator \--net=host \-v /var/run/docker.sock:/tmp/docker.sock \gliderlabs/registrator \-ip 192.168.1.15 \consul://192.168.1.15:8500</code></pre><pre><code>docker run -d \--restart=always \--name=registrator \--net=host \-v /var/run/docker.sock:/tmp/docker.sock \gliderlabs/registrator \-ip 192.168.1.16 \consul://192.168.1.16:8500</code></pre><h2 id="四、安装shipyard、swarm"><a href="#四、安装shipyard、swarm" class="headerlink" title="四、安装shipyard、swarm"></a>四、安装shipyard、swarm</h2><p>1、192.168.1.14</p><pre><code>docker run -tid \-p 3375:3375 \--restart=always \--name shipyard-swarm-manager \swarm:latest \manage --host tcp://0.0.0.0:3375 consul://192.168.1.14:8500</code></pre><pre><code>docker run -tid \--restart=always \--name=shipyard-rethinkdb \-p 28015:28015 \-p 29015:29015 \-v /opt/rethinkdb:/data \index.tenxcloud.com/docker_library/rethinkdb</code></pre><pre><code>docker run -tid \--restart=always \--name shipyard-controller \--link shipyard-rethinkdb:rethinkdb \--link shipyard-swarm-manager:swarm \-p 8080:8080 \dockerclub/shipyard:latest \server \-d tcp://swarm:3375</code></pre><pre><code>docker run -tid \--restart=always \--name shipyard-swarm-agent \swarm:latest \join --addr 192.168.1.14:2375 consul://192.168.1.14:8500</code></pre><h1 id="2、安装swarm-agent"><a href="#2、安装swarm-agent" class="headerlink" title="2、安装swarm-agent"></a>2、安装swarm-agent</h1><p>主机192.168.1.15操作</p><pre><code>docker run -tid \--restart=always \--name shipyard-swarm-agent \swarm:latest \join --addr 192.168.1.15:2375 consul://192.168.1.14:8500</code></pre><p>主机192.168.1.16操作</p><pre><code>docker run -tid \--restart=always \--name shipyard-swarm-agent \swarm:latest \join --addr 192.168.1.16:2375 consul://192.168.1.14:8500</code></pre><h2 id="五、安装haproxy或者nginx（192-168-1-14）"><a href="#五、安装haproxy或者nginx（192-168-1-14）" class="headerlink" title="五、安装haproxy或者nginx（192.168.1.14）"></a>五、安装haproxy或者nginx（192.168.1.14）</h2><h1 id="1、安装haproxy"><a href="#1、安装haproxy" class="headerlink" title="1、安装haproxy"></a>1、安装haproxy</h1><pre><code>yum -y install git patch gcc gcc-c++  readline-devel zlib-devel libffi-devel \openssl openssl-devel make autoconf automake libtool bison libxml2 \libxml2-devel libxslt-devel libyaml-devel  python  python-docutils \cmake imake expat-devel libaio libaio-devel bzr ncurses-devel wget \libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel  \pcre-devel curl-devel libmcrypt libmcrypt-develcd /tmpwget http://www.haproxy.org/download/1.7/src/haproxy-1.7.0.tar.gztar -xvf /tmp/haproxy-1.7.0.tar.gz make TARGET=linux31 PREFIX=/opt/haproxymake install PREFIX=/opt/haproxy</code></pre><h1 id="2、配置haproxy-conf"><a href="#2、配置haproxy-conf" class="headerlink" title="2、配置haproxy.conf"></a>2、配置haproxy.conf</h1><pre><code>vim /opt/haproxy/conf/haproxy.confglobal                log 127.0.0.1   local0                #log 127.0.0.1  local1 notice                #log loghost    local0 info                maxconn 50000                chroot /opt/haproxy                uid 99                gid 99                daemon                nbproc 2                pidfile /opt/haproxy/run/haproxy.pid                #debug                #quiet defaults                mode    tcp                option  dontlognull                option  forwardfor                option  redispatch                retries 2                balance static-rr                stats enable                stats uri /ha?stats  #haproxy运行状态查看 自定义uri                timeout connect     3000                timeout client      50000                timeout server 50000listen admin_stat        # 监听端口        bind *:8888        # http的7层模式        mode http        #log global        # 统计页面自动刷新时间        stats refresh 30s        # 统计页面URL        stats uri /admin?stats        # 统计页面密码框上提示文本        stats realm Haproxy\ Statistics        # 统计页面用户名和密码设置        stats auth admin:admin        # 隐藏统计页面上HAProxy的版本信息        #stats hide-versionlisten login        bind *:9999        mode tcp        balance roundrobin        option httpchk        #maxconn 50000        #log 127.0.0.1 local0 debug</code></pre><h1 id="3、haproxy启动脚本-etc-init-d-haproxy"><a href="#3、haproxy启动脚本-etc-init-d-haproxy" class="headerlink" title="3、haproxy启动脚本 /etc/init.d/haproxy"></a>3、haproxy启动脚本 /etc/init.d/haproxy</h1><pre><code>#! /bin/bash# chkconfig: - 85 15# description: haproxy is a World Wide Web server. It is used to servePROGDIR=/opt/haproxyPROGNAME=haproxyDAEMON=$PROGDIR/sbin/$PROGNAMECONFIG=$PROGDIR/conf/$PROGNAME.confPIDFILE=$PROGDIR/run/$PROGNAME.pidDESC=&quot;HAProxy daemon&quot;SCRIPTNAME=/opt/haproxy/init.d/$PROGNAME# Gracefully exit if the package has been removed.test -x $DAEMON || exit 0start() {    echo -n &quot;Starting $DESC: $PROGNAME&quot;   $DAEMON -f $CONFIG   echo &quot;.&quot;        }stop() {  echo -n &quot;Stopping $DESC: $PROGNAME&quot;    cat $PIDFILE | xargs kill    echo &quot;.&quot;}reload() { echo -n &quot;reloading $DESC: $PROGNAME&quot;   $DAEMON -f $CONFIG -p $PIDFILE -sf $(cat $PIDFILE)}case &quot;$1&quot; in  start)  start  ;; stop)  stop   ;; reload) reload   ;;*) echo &quot;Usage: $SCRIPTNAME {start|stop|reload}&quot; &gt;&amp;2 exit 1 ;;esacexit 0</code></pre><h1 id="4、启动haproxy-并加入到开启启动"><a href="#4、启动haproxy-并加入到开启启动" class="headerlink" title="4、启动haproxy,并加入到开启启动"></a>4、启动haproxy,并加入到开启启动</h1><pre><code>chmod +x /etc/init.d/haproxychkconfig haproxy opservice haproxy start</code></pre><h1 id="5、安装nginx-并支持数字证书"><a href="#5、安装nginx-并支持数字证书" class="headerlink" title="5、安装nginx 并支持数字证书"></a>5、安装nginx 并支持数字证书</h1><pre><code>yum -y install git patch gcc gcc-c++  readline-devel zlib-devel libffi-devel \ openssl openssl-devel make autoconf automake libtool bison libxml2 \ libxml2-devel libxslt-devel libyaml-devel  python  python-docutils \ cmake imake expat-devel libaio libaio-devel bzr ncurses-devel wget \ libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel  \ pcre-devel curl-devel libmcrypt libmcrypt-devel</code></pre><h1 id="6、下载安装openssl"><a href="#6、下载安装openssl" class="headerlink" title="6、下载安装openssl"></a>6、下载安装openssl</h1><pre><code> cd /tmpwget https://www.openssl.org/source/openssl-1.1.0c.tar.gz tar -xvf openssl-1.1.0c.tar.gz cd /tmp/openssl-1.1.0c./config   --openssldir=/usr/local/sslmake &amp;&amp; make install./config shared  --openssldir=/usr/local/sslmake cleanmake &amp;&amp; make install</code></pre><h1 id="7、下载安装-nginx"><a href="#7、下载安装-nginx" class="headerlink" title="7、下载安装 nginx"></a>7、下载安装 nginx</h1><pre><code>cd /tmpwget http://nginx.org/download/nginx-1.11.7.tar.gzgroupadd -r nginxuseradd -g nginx -r nginx -s /bin/falsetar -xvf nginx-1.11.7.tar.gzcd /tmp/nginx-1.11.7./configure --prefix=/usr/local/nginx \--sbin-path=/usr/sbin/nginx \--conf-path=/etc/nginx/nginx.conf \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--pid-path=/var/run/nginx.pid \--lock-path=/var/run/nginx.lock \--http-client-body-temp-path=/var/cache/nginx/client_temp \--http-proxy-temp-path=/var/cache/nginx/proxy_temp \--http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \--http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \--http-scgi-temp-path=/var/cache/nginx/scgi_temp \--user=nginx \--group=nginx \--with-http_ssl_module \--with-http_realip_module \--with-http_addition_module \--with-http_sub_module \--with-http_dav_module \--with-http_flv_module \--with-http_mp4_module \--with-http_gunzip_module \--with-http_gzip_static_module \--with-http_random_index_module \--with-http_secure_link_module \--with-http_stub_status_module \--with-http_auth_request_module \--with-threads \--with-stream \--with-openssl=/tmp/openssl-1.1.0c \--with-stream_ssl_module \--with-http_slice_module \--with-mail \--with-mail_ssl_module \--with-file-aio \--with-http_v2_module \--with-ipv6 mkdir -pv /var/cache/nginx/{client_temp,proxy_temp,fastcgi_temp,uwsgi_temp,scgi_temp}mkdir -p /etc/nginx/conf.dmake &amp;&amp; make install</code></pre><h1 id="8、nginx配置文件"><a href="#8、nginx配置文件" class="headerlink" title="8、nginx配置文件"></a>8、nginx配置文件</h1><p>修改/etc/nginx/nginx.conf<br>user  nginx;<br>worker_processes  1;</p><p>error_log  /var/log/nginx/error.log warn;<br>pid        /var/run/nginx.pid;</p><p>events {<br>    worker_connections  1024;<br>}</p><p>http {<br>    include       /etc/nginx/mime.types;<br>    default_type  application/octet-stream;</p><pre><code>log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;access_log  /var/log/nginx/access.log  main;sendfile        on;tcp_nopush     on;keepalive_timeout  65;gzip  on;include /etc/nginx/conf.d/*.conf;</code></pre><p>}</p><p>添加nginx默认web配置文件<br>/etc/nginx/conf.d/default.conf<br>server {<br>        listen       80;<br>        server_name  localhost;</p><pre><code>    #charset koi8-r;    #access_log  logs/host.access.log  main;    location / {        root   /usr/local/nginx/html;        index  index.php index.html index.htm;    }    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   html;    }    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ {    #    proxy_pass   http://127.0.0.1;    #}    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    location ~ \.php$ {        root           /usr/local/nginx/html;        fastcgi_pass   127.0.0.1:9000;        fastcgi_index  index.php;        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;        include        fastcgi_params;    }    location ~* ^.+\.(jpg|jpeg|gif|png|bmp)$ {        access_log  off;        root        opencart;        expires     30d;                    break;    }</code></pre><p>}</p><h1 id="9、创建nginx启动脚本-etc-init-d-nginx"><a href="#9、创建nginx启动脚本-etc-init-d-nginx" class="headerlink" title="9、创建nginx启动脚本 /etc/init.d/nginx"></a>9、创建nginx启动脚本 /etc/init.d/nginx</h1><pre><code># chkconfig: 2345 10 90# description: Start and Stop redisPATH=/usr/local/bin:/sbin:/usr/bin:/binEXEC=/usr/sbin/nginxPIDFILE=/var/run/nginx.pidCONF=&quot;/etc/nginx/nginx.conf&quot;AUTH=&quot;1234&quot;case &quot;$1&quot; in        start)                if [ -f $PIDFILE ]                then                        echo &quot;$PIDFILE exists, process is already running or crashed.&quot;                else                        echo &quot;Starting nginx server...&quot;                        $EXEC &amp;                fi                if [ &quot;$?&quot;=&quot;0&quot; ]                then                        echo &quot;nginx is running...&quot;                fi                ;;        stop)                if [ ! -f $PIDFILE ]                then                        echo &quot;$PIDFILE exists, process is not running.&quot;                else                        PID=$(cat $PIDFILE)                        echo &quot;Stopping...&quot;                        kill -9 $PID                        PID=$(pidof nginx)                        kill -9 $PID                        rm -rf /var/run/nginx.pid                        sleep 2                       while [ -x $PIDFILE ]                       do                                echo &quot;Waiting for nginx to shutdown...&quot;                               sleep 1                        done                        echo &quot;nginx stopped&quot;                fi                ;;        restart|reload)                ${0} stop                ${0} start                ;;        *)               echo &quot;Usage: /etc/init.d/nginx {start|stop|restart|reload}&quot; &gt;&amp;2                exit 1esac</code></pre><h1 id="10、设置nginx开机启动"><a href="#10、设置nginx开机启动" class="headerlink" title="10、设置nginx开机启动"></a>10、设置nginx开机启动</h1><pre><code>chmod +x /etc/init.d/nginxchkconfig nginx onservice nginx start</code></pre><h2 id="六、安装consul-template-实现服务自动发现"><a href="#六、安装consul-template-实现服务自动发现" class="headerlink" title="六、安装consul-template 实现服务自动发现"></a>六、安装consul-template 实现服务自动发现</h2><h1 id="1、下载consul-template"><a href="#1、下载consul-template" class="headerlink" title="1、下载consul-template"></a>1、下载consul-template</h1><pre><code>cd /tmpwget https://releases.hashicorp.com/consul-template/0.16.0/consul-template_0.16.0_linux_amd64.zipyum -y install unzipunzip /tmp/consul-template_0.16.0_linux_amd64.zip -d /usr/bin/</code></pre><h1 id="2、consul-template-haproxy配置"><a href="#2、consul-template-haproxy配置" class="headerlink" title="2、consul-template haproxy配置"></a>2、consul-template haproxy配置</h1><pre><code>cat &gt; /opt/consul/conf/haproxy_ctmpl.json &lt;&lt; EOFconsul = &quot;127.0.0.1:8500&quot;template {  source = &quot;/opt/haproxy/conf/haproxy.ctmpl&quot;  destination = &quot;/opt/haproxy/conf/haproxy.conf&quot;  command = &quot;/etc/init.d/haproxy reload&quot;}EOF3、haproxy.ctmpl配置 /opt/haproxy/conf/haproxy.ctmplglobal                  log 127.0.0.1   local0                  #log 127.0.0.1  local1 notice                  #log loghost    local0 info                  maxconn 50000                  chroot /opt/haproxy                uid 99                  gid 99                 daemon                  nbproc 2                pidfile /opt/haproxy/run/haproxy.pid                  #debug                  #quiet   defaults                  mode    tcp                  option  dontlognull                  option  forwardfor                  option  redispatch                  retries 2                  balance static-rr                stats enable                stats uri /ha?stats                 timeout connect     3000                  timeout client      50000                  timeout server 50000  listen admin_stat          bind *:8888            mode http          #log global           stats refresh 30s          stats uri /admin?stats          stats realm Haproxy\ Statistics         stats auth admin:admin         #stats hide-version  frontend www         bind *:80         mode http         acl apache  hdr(HOST) apache.zone.com         acl nginx   hdr(HOST) nginx.zone.com         use_backend apache.qkazone.com if apache         use_backend nginx.qkazone.com if nginxbackend apache.zone.com        balance         roundrobin        mode            http{{range service "apache-php-80"}}        server  apache {{.Address}}:{{.Port}} check {{end}}backend nginx.zone.com        mode http        balance         roundrobin{{range service "nginx-80"}}        server  nginx {{.Address}}:{{.Port}} check {{end}}listen login        bind *:9999        mode tcp        balance roundrobin        #log 127.0.0.1 local0 debug        {{range service "centos7"}}        server  ssh {{.Address}}:{{.Port}} check {{end}}</code></pre><h1 id="4、配置consul-template-haproxy-启动脚本-etc-init-d-haproxy-ctmpl"><a href="#4、配置consul-template-haproxy-启动脚本-etc-init-d-haproxy-ctmpl" class="headerlink" title="4、配置consul-template  haproxy 启动脚本 /etc/init.d/haproxy_ctmpl"></a>4、配置consul-template  haproxy 启动脚本 /etc/init.d/haproxy_ctmpl</h1><pre><code>#!/bin/bash# chkconfig: 2345 10 90# description: Start and Stop redisPATH=/usr/local/bin:/sbin:/usr/bin:/binEXEC=/usr/bin/consul-templateCONF=&quot;/opt/consul/conf/haproxy_ctmpl.json&quot;case &quot;$1&quot; in        start)                 PID=$(ps -ef | grep -v grep  | grep &quot;$EXEC -config $CONF&quot; | awk &#39;{print $2}&#39;)               if [ -n &quot;$PID&quot;   ]                   then                     echo &quot;haproxy_ctmpl is running...&quot;              else                echo &quot;Starting haproxy_ctmpl server...&quot;                        $EXEC -config $CONF &gt; /tmp/haproxy_ctmpl.out 2&gt;&amp;1 &amp;             fi             ;;       stop)            PID=$(ps -ef | grep -v grep  | grep &quot;$EXEC -config $CONF&quot; | awk &#39;{print $2}&#39;)            if [  -n &quot;$PID&quot; ]                 then                        echo &quot;Stopping...&quot;                        kill -9 $PID                        sleep 2               else               echo &quot;haproxy_ctmpl exists, process is not running.&quot;             fi             ;;       restart|force-reload)                ${0} stop                ${0} start                ;;*)               echo &quot;Usage: /etc/init.d/tmpl {start|stop|restart|force-reload}&quot; &gt;&amp;2                exit 1esac</code></pre><h1 id="5、设置开机启动，启动"><a href="#5、设置开机启动，启动" class="headerlink" title="5、设置开机启动，启动"></a>5、设置开机启动，启动</h1><pre><code>chmod +x /etc/init.d/haproxy_ctmplchkconfig haproxy_ctmpl onservice haproxy_ctmpl start</code></pre><h1 id="6、consul-template-nginx配置-opt-consul-conf-nginx-ctmpl-json"><a href="#6、consul-template-nginx配置-opt-consul-conf-nginx-ctmpl-json" class="headerlink" title="6、consul-template  nginx配置 /opt/consul/conf/nginx_ctmpl.json"></a>6、consul-template  nginx配置 /opt/consul/conf/nginx_ctmpl.json</h1><pre><code>cat &gt; /opt/consul/conf/nginx_ctmpl.json &lt;&lt; EOFconsul = &quot;127.0.0.1:8500&quot;template {  source = &quot;/etc/nginx/conf.d/nginx_web.ctmpl&quot;  destination = &quot;/etc/nginx/conf.d/nginx_web.conf&quot;  command = &quot;/usr/sbin/nginx  -s reload&quot;}EOF</code></pre><h1 id="7、-etc-nginx-conf-d-nginx-web-ctmpl-配置"><a href="#7、-etc-nginx-conf-d-nginx-web-ctmpl-配置" class="headerlink" title="7、/etc/nginx/conf.d/nginx_web.ctmpl 配置"></a>7、/etc/nginx/conf.d/nginx_web.ctmpl 配置</h1><pre><code>upstream apache {    ip_hash;    # Refer: http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream    # least_conn;    # least_time;{{range service "apache-php-80"}}    server {{.Address}}:{{.Port}} fail_timeout=0;{{end}}    keepalive 64;}server {    listen 80;    server_name apache.zone.com;    location / {        client_max_body_size    0;        proxy_connect_timeout 300s;        proxy_send_timeout   900;        proxy_read_timeout   900;        proxy_buffer_size    32k;        proxy_buffers      4 32k;        proxy_busy_buffers_size 64k;        proxy_redirect     off;        proxy_hide_header  Vary;        proxy_set_header   Accept-Encoding &#39;&#39;;        proxy_set_header   Host   $host;        proxy_set_header   Referer $http_referer;        proxy_set_header   Cookie $http_cookie;        proxy_set_header   X-Real-IP  $remote_addr;        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header   Host $host;        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_headers_hash_max_size 51200;        proxy_headers_hash_bucket_size 6400;        proxy_pass          http://apache/;    }}upstream nginx {    ip_hash;    # Refer: http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream    # least_conn;    # least_time;{{range service "nginx-80"}}    server {{.Address}}:{{.Port}} fail_timeout=0;{{end}}    keepalive 64;}server {    listen 80;    server_name nginx.zone.com;    location / {        client_max_body_size    0;        proxy_connect_timeout 300s;        proxy_send_timeout   900;        proxy_read_timeout   900;        proxy_buffer_size    32k;        proxy_buffers      4 32k;        proxy_busy_buffers_size 64k;        proxy_redirect     off;        proxy_hide_header  Vary;        proxy_set_header   Accept-Encoding &#39;&#39;;        proxy_set_header   Host   $host;        proxy_set_header   Referer $http_referer;        proxy_set_header   Cookie $http_cookie;        proxy_set_header   X-Real-IP  $remote_addr;        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header   Host $host;        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_headers_hash_max_size 51200;        proxy_headers_hash_bucket_size 6400;        proxy_pass          http://nginx/;    }}</code></pre><h1 id="8、配置consul-template-nginx启动脚本-etc-init-d-nginx-ctmpl"><a href="#8、配置consul-template-nginx启动脚本-etc-init-d-nginx-ctmpl" class="headerlink" title="8、配置consul-template  nginx启动脚本 /etc/init.d/nginx_ctmpl"></a>8、配置consul-template  nginx启动脚本 /etc/init.d/nginx_ctmpl</h1><pre><code>#!/bin/bash# chkconfig: 2345 10 90# description: Start and Stop redisPATH=/usr/local/bin:/sbin:/usr/bin:/binEXEC=/usr/bin/consul-templateCONF=&quot;/opt/consul/conf/nginx_ctmpl.json&quot;case &quot;$1&quot; in        start)                 PID=$(ps -ef | grep -v grep  | grep &quot;$EXEC -config $CONF&quot; | awk &#39;{print $2}&#39;)               if [ -n &quot;$PID&quot;   ]                   then                     echo &quot;haproxy_ctmpl is running...&quot;              else                echo &quot;Starting haproxy_ctmpl server...&quot;                        $EXEC -config $CONF &gt; /tmp/nginx_ctmpl.out 2&gt;&amp;1 &amp;             fi             ;;       stop)            PID=$(ps -ef | grep -v grep  | grep &quot;$EXEC -config $CONF&quot; | awk &#39;{print $2}&#39;)            if [  -n &quot;$PID&quot; ]                 then                        echo &quot;Stopping...&quot;                        kill -9 $PID                        sleep 2               else               echo &quot;haproxy_ctmpl exists, process is not running.&quot;             fi             ;;       restart|force-reload)                ${0} stop                ${0} start                ;;*)               echo &quot;Usage: /etc/init.d/tmpl {start|stop|restart|force-reload}&quot; &gt;&amp;2                exit 1esac</code></pre><h1 id="9、设置开机启动"><a href="#9、设置开机启动" class="headerlink" title="9、设置开机启动"></a>9、设置开机启动</h1><pre><code>chmod +x /etc/init.d/nginx_ctmplchkconfig nginx_ctmpl onservice nginx_ctmpl start</code></pre><h2 id="七、测试是否自动发现"><a href="#七、测试是否自动发现" class="headerlink" title="七、测试是否自动发现"></a>七、测试是否自动发现</h2><pre><code>docker run -ti -d -p :80 eboraas/apache-php docker run -d -ti -p :80 nginx</code></pre><p>1、consul web<br><a href="http://192.168.1.66:8500/ui/#/dc1/services" target="_blank" rel="noopener">http://192.168.1.66:8500/ui/#/dc1/services</a></p><p>2、shipyard web<br><a href="http://192.168.1.23:8080" target="_blank" rel="noopener">http://192.168.1.23:8080</a><br>账号admin密码 shipyard</p><p>3、haproxy web<br><a href="http://192.168.1.14:8888/admin?stats" target="_blank" rel="noopener">http://192.168.1.14:8888/admin?stats</a><br>账号：admin 密码admin<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言&lt;br&gt;Swarm项目是Docker公司发布三剑客中的一员，用来提供容器集群服务，目的是更好的帮助用户管理多个Docker Engine，方便用户使用，像使用Docker Engine一样使用容器集群服务。这次分享内容从Swarm项目现状、Swarm社区现状和Swarm未来的一些规划三方面介绍Swarm，目的是能让大家对Swarm有个完整的认识，并且希望更多的人采用到Swarm项目中来。&lt;br&gt;此文主要是swarm docker集群部署，仅供参考&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://ippai.top/categories/Docker/"/>
    
    
      <category term="linux自动化运维" scheme="http://ippai.top/tags/linux%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://ippai.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker-redis集群</title>
    <link href="http://ippai.top/2018/04/08/docker-redis%E9%9B%86%E7%BE%A4/"/>
    <id>http://ippai.top/2018/04/08/docker-redis集群/</id>
    <published>2018-04-08T03:16:46.000Z</published>
    <updated>2018-04-09T03:39:31.309Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。<br>此文只要是针对基于docker部署redis集群，实现主从同步<br><a id="more"></a><br>master    192.168.1.14<br>slave    192.168.1.15</p><h2 id="master操作"><a href="#master操作" class="headerlink" title="master操作"></a>master操作</h2><h1 id="1-创建数据文件"><a href="#1-创建数据文件" class="headerlink" title="1.创建数据文件"></a>1.创建数据文件</h1><pre><code>mkdir /opt/redis</code></pre><h1 id="2-拉取redis镜像"><a href="#2-拉取redis镜像" class="headerlink" title="2.拉取redis镜像"></a>2.拉取redis镜像</h1><pre><code>docker pull benyoo/redis:3.2.5</code></pre><h1 id="3-配置redis文件"><a href="#3-配置redis文件" class="headerlink" title="3.配置redis文件"></a>3.配置redis文件</h1><pre><code>echo &#39;bind 0.0.0.0protected-mode yesport 6379tcp-backlog 511timeout 0tcp-keepalive 300daemonize nosupervised nopidfile /var/run/redis_6379.pidloglevel noticelogfile &quot;&quot;databases 8save 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yesdbfilename dump.rdbdir /data/redisslave-serve-stale-data yesslave-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-disable-tcp-nodelay noslave-priority 100appendonly noappendfilename &quot;appendonly.aof&quot;appendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yeslua-time-limit 5000slowlog-log-slower-than 10000slowlog-max-len 128latency-monitor-threshold 0notify-keyspace-events &quot;&quot;hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-size -2list-compress-depth 0set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 10aof-rewrite-incremental-fsync yesmasterauth ZDU0NTlkNDY5NWZirequirepass ZDU0NTlkNDY5NWZi&#39; &gt;/opt/redis/redis.conf</code></pre><h1 id="4-配置防火墙"><a href="#4-配置防火墙" class="headerlink" title="4.配置防火墙"></a>4.配置防火墙</h1><pre><code>iptables -I INPUT 5 -p tcp -m state --state NEW -m tcp -m comment --comment &quot;REDIS_SERVER&quot; -m multiport --dports 6379 -j ACCEPTiptables -nvxL --lin</code></pre><h1 id="5-启动redis容器"><a href="#5-启动redis容器" class="headerlink" title="5.启动redis容器"></a>5.启动redis容器</h1><pre><code>docker run -d \--privileged=true \--name redis-master \--restart=always \-p 6379:6379-v /opt/redis/redis.conf:/etc/redis.conf \-v /etc/localtime:/etc/localtime \benyoo/redis:3.2.5</code></pre><h2 id="slave上操作"><a href="#slave上操作" class="headerlink" title="slave上操作"></a>slave上操作</h2><h1 id="1-创建数据文件-1"><a href="#1-创建数据文件-1" class="headerlink" title="1.创建数据文件"></a>1.创建数据文件</h1><pre><code>mkdir /opt/redis</code></pre><p>2.拉取redis镜像</p><pre><code>docker pull benyoo/redis:3.2.5</code></pre><p>3.配置redis文件</p><pre><code>echo &#39;bind 0.0.0.0protected-mode yesport 6379tcp-backlog 511timeout 0tcp-keepalive 300daemonize nosupervised nopidfile /var/run/redis_6379.pidloglevel noticelogfile &quot;&quot;databases 8save 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yesdbfilename dump.rdbdir /data/redisslave-serve-stale-data yesslave-read-only yesrepl-diskless-sync norepl-diskless-sync-delay 5repl-disable-tcp-nodelay noslave-priority 100appendonly noappendfilename &quot;appendonly.aof&quot;appendfsync everysecno-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yeslua-time-limit 5000slowlog-log-slower-than 10000slowlog-max-len 128latency-monitor-threshold 0notify-keyspace-events &quot;&quot;hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-size -2list-compress-depth 0set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000activerehashing yesclient-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60hz 10aof-rewrite-incremental-fsync yesslaveof 192.168.1.14 6379masterauth ZDU0NTlkNDY5NWZirequirepass ZDU0NTlkNDY5NWZi&#39; &gt;/opt/redis/redis.conf</code></pre><h1 id="4-配置防火墙-1"><a href="#4-配置防火墙-1" class="headerlink" title="4.配置防火墙"></a>4.配置防火墙</h1><pre><code>iptables -I INPUT 5 -p tcp -m state --state NEW -m tcp -m comment --comment &quot;REDIS_SERVER&quot; -m multiport --dports 6379 -j ACCEPTiptables -nvxL --lin</code></pre><h1 id="5-启动redis容器-1"><a href="#5-启动redis容器-1" class="headerlink" title="5.启动redis容器"></a>5.启动redis容器</h1><pre><code>docker run -d \--privileged=true \--name redis-slave \--restart=always \-p 6379:6379-v /opt/redis/redis.conf:/opt/redis/redis.conf \-v /etc/localtime:/etc/localtime \benyoo/redis:3.2.5</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code>docker exec -it redis redis-cli -h 192.168.1.15 -a ZDU0NTlkNDY5NWZi info replication# Replicationrole:slavemaster_host:192.168.1.14master_port:6379master_link_status:upmaster_last_io_seconds_ago:9master_sync_in_progress:0slave_repl_offset:281slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0</code></pre><pre><code>docker exec -it redis redis-cli -h 192.168.1.14 -a ZDU0NTlkNDY5NWZi info replication # Replicationrole:masterconnected_slaves:1slave0:ip=192.168.1.15,port=6379,state=online,offset=295,lag=1master_repl_offset:295repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:294</code></pre><pre><code>docker exec -it redis redis-cli -h 192.168.1.14 -a ZDU0NTlkNDY5NWZi set Test_Write_key www.shangtv.cn         #创建数据OK</code></pre><pre><code>docker exec -it redis redis-cli -h 192.168.1.14 -a ZDU0NTlkNDY5NWZi get Test_Write_key www.shangtv.cn</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言&lt;br&gt;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。&lt;br&gt;此文只要是针对基于docker部署redis集群，实现主从同步&lt;br&gt;
    
    </summary>
    
    
      <category term="linux自动化运维" scheme="http://ippai.top/tags/linux%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://ippai.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>registry v2搭建</title>
    <link href="http://ippai.top/2018/04/08/registry-v2%E6%90%AD%E5%BB%BA/"/>
    <id>http://ippai.top/2018/04/08/registry-v2搭建/</id>
    <published>2018-04-08T03:16:20.000Z</published>
    <updated>2018-04-09T03:46:31.427Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>新版 registry v2对镜像存储格式进行了重新设计，并且和旧版还不兼容。registry v2是由go语言开发，docker从1.6版本开始支持registry v2，之前python开发的老版registry在网上已被标为废弃了（没有维护更新，但也可以用）。</p><p>之前在测试环境搭建了一个老版的registry，用了也比较久了。为了跟上技术的脚步，也准备今后使用新版registry v2。由于对旧版是不兼容的，所以之前仓库的数据目录还不能直接拿来挂载，只好重新做个新的，镜像只好等以后慢慢再放上去了。下面对我这次配置的步骤简单的介绍一下。<br><a id="more"></a></p><h1 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h1><p>本次使用centos7.3的操作系统，服务器IP假设为：192.168.0.100<br>预先装好docker服务，操作如下：</p><h1 id="添加docker-repo安装源，写入文件"><a href="#添加docker-repo安装源，写入文件" class="headerlink" title="添加docker.repo安装源，写入文件"></a>添加docker.repo安装源，写入文件</h1><pre><code>tee /etc/yum.repos.d/docker.repo&lt;&lt;EOF[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/main/centos/7/enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpgEOF</code></pre><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><pre><code>yum install docker-engine -ysystemctl enable dockersystemctl start docker</code></pre><h1 id="1-获取最新的registry的容器-了解到目前最新版为2-4-1，于是直接使用docker-pull命令从公用仓库去拉即可"><a href="#1-获取最新的registry的容器-了解到目前最新版为2-4-1，于是直接使用docker-pull命令从公用仓库去拉即可" class="headerlink" title="1. 获取最新的registry的容器,了解到目前最新版为2.4.1，于是直接使用docker pull命令从公用仓库去拉即可"></a>1. 获取最新的registry的容器,了解到目前最新版为2.4.1，于是直接使用docker pull命令从公用仓库去拉即可</h1><pre><code>docker pull registry:2.4.1</code></pre><h1 id="2-运行registry-2-4-1容器"><a href="#2-运行registry-2-4-1容器" class="headerlink" title="2. 运行registry:2.4.1容器"></a>2. 运行registry:2.4.1容器</h1><p>这里需要注意的是新registry仓库数据目录的位置。之前老版的位置是/tmp/registry，hub.docker.com上的演示命令里写的是/tmp/registry-dev，其实这个不对。试验证明，新registry的仓库目录是在/var/lib/registry，所以运行时挂载目录需要注意。</p><pre><code>docker run -d -p 5000:5000 --restart=always \-v /opt/registry-var/:/var/lib/registry/ \registry:2.4.1</code></pre><p>-v选项指定将/opt/registry-var/目录挂载给/var/lib/registry/<br>当使用curl <a href="http://192.168.0.100:5000/v2/_catalog能看到json格式的返回值时，说明registry已经运行起来了。" target="_blank" rel="noopener">http://192.168.0.100:5000/v2/_catalog能看到json格式的返回值时，说明registry已经运行起来了。</a></p><h1 id="3-修改配置文件以指定registry地址"><a href="#3-修改配置文件以指定registry地址" class="headerlink" title="3. 修改配置文件以指定registry地址"></a>3. 修改配置文件以指定registry地址</h1><p>上面registry虽然已经运行起来了，但是如果想用push命令上传镜像是会报错的，需要在配置文件中指定registry的地址。在/lib/systemd/system/docker.service文件中添加一下配置：<br>–insecure-registry 192.168.0.100:5000’</p><p>为了配置简单，省去安全相关的配置，这里使用–insecure-registry选项修改配置文件后，一定要重启docker服务才能生效，</p><pre><code>systemctl restart docker</code></pre><p>这时再push就可以上传镜像到所搭建的registry仓库了。需要注意的是，上传前要先给镜像tag一个192.168.0.100:5000/为前缀的名字，这样才能在push的时候存到私库。</p><pre><code>docker tag docker.io/registry:2.4.1 192.168.0.100:5000/registry:2.4.1docker push 192.168.0.100:5000/registry:2.4.1</code></pre><h1 id="4-配置带用户权限的registry"><a href="#4-配置带用户权限的registry" class="headerlink" title="4. 配置带用户权限的registry"></a>4. 配置带用户权限的registry</h1><p>到上面为止，registry已经可以使用了。如果想要控制registry的使用权限，使其只有在登录用户名和密码之后才能使用的话，还需要做额外的设置。</p><p>registry的用户名密码文件可以通过htpasswd来生成：</p><pre><code>mkdir /opt/registry-var/auth/docker run --entrypoint htpasswd registry:2.4.1 -Bbn felix felix  &gt;&gt; /opt/registry-var/auth/htpasswd</code></pre><p>上面这条命令是为felix用户名生成密码为felix的一条用户信息，存在/opt/registry-var/auth/htpasswd文件里面，文件中存的密码是被加密过的。<br>使用带用户权限的registry时候，容器的启动命令就跟上面不一样了，将之前的容器停掉并删除，然后执行下面的命令：</p><pre><code>docker run -d -p 5000:5000 --restart=always \-v /opt/registry-var/auth/:/auth/ \-e &quot;REGISTRY_AUTH=htpasswd&quot; \-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \-v /opt/registry-var/:/var/lib/registry/ \registry:2.4.1</code></pre><p>这时，如果直接想查看仓库信息、pull或push都会出现权限报错。必须先使用docker login 命令来登录私有仓库：</p><pre><code>docker login 192.168.0.100:5000</code></pre><p>根据提示，输入用户名和密码即可。如果登录成功，会在/root/.docker/config.json文件中保存账户信息，这样就可以继续使用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言&lt;br&gt;新版 registry v2对镜像存储格式进行了重新设计，并且和旧版还不兼容。registry v2是由go语言开发，docker从1.6版本开始支持registry v2，之前python开发的老版registry在网上已被标为废弃了（没有维护更新，但也可以用）。&lt;/p&gt;
&lt;p&gt;之前在测试环境搭建了一个老版的registry，用了也比较久了。为了跟上技术的脚步，也准备今后使用新版registry v2。由于对旧版是不兼容的，所以之前仓库的数据目录还不能直接拿来挂载，只好重新做个新的，镜像只好等以后慢慢再放上去了。下面对我这次配置的步骤简单的介绍一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="linux自动化运维" scheme="http://ippai.top/tags/linux%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="http://ippai.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>etcd集群</title>
    <link href="http://ippai.top/2018/04/08/etcd%E9%9B%86%E7%BE%A4/"/>
    <id>http://ippai.top/2018/04/08/etcd集群/</id>
    <published>2018-04-08T02:47:45.000Z</published>
    <updated>2018-04-09T03:45:34.577Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>Etcd:一个键值存储仓库，主要用于配置共享和服务发现。<br>优点：<br>    简单：支持 curl 方式的用户 API (HTTP+JSON)<br>    安全：可选 SSL 客户端证书认证<br>    快速：单实例可达每秒 1000 次写操作<br>    可靠：使用 Raft 实现分布式</p><p>本文主要阐述集群etcd的部署<br><a id="more"></a><br>安装etcd可以通过源码编译安装，也可以用yum安装，这里实验用yum安装<br>Configure epel yum</p><pre><code>wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm &amp;&amp; rpm -ivh epel-release-latest-7.noarch.rpm</code></pre><p>install etcd</p><pre><code>yum install -y etcd</code></pre><p>configure host</p><pre><code>echo &quot;etcd1 192.168.1.100&quot; &gt;&gt; /etc/hostsecho &quot;etcd2 192.168.1.200&quot; &gt;&gt; /etc/hosts</code></pre><pre><code>IP=$(ifconfig  eth1 |awk  -F &#39;[: ]+&#39; &#39;NR==2{print $3}&#39;)IP1=192.168.1.100IP2=192.168.1.200HOST=&quot;etcd1=http://192.168.1.100:2380,etcd2=http://192.168.1.200:2380&quot;</code></pre><pre><code>function node1{#Configure the node1 etcd filesed -i &#39;s#\#ETCD_LISTEN_PEER_URLS=&quot;http://localhost:2380&quot;#ETCD_LISTEN_PEER_URLS=&quot;http://${IP1}:2380&quot;#g&#39; /etc/etcd/etcd.confsed -i &#39;s#ETCD_LISTEN_CLIENT_URLS=&quot;http://localhost:2379&quot;#ETCD_LISTEN_CLIENT_URLS=&quot;http://0.0.0.0:2379&quot;#g&#39; /etc/etcd/etcd.confsed -i &#39;s#ETCD_ADVERTISE_CLIENT_URLS=&quot;http://localhost:2379&quot;#ETCD_ADVERTISE_CLIENT_URLS=&quot;http://${IP1}:2379&quot;#g&#39; /etc/etcd/etc.confsed -i &#39;s#\#ETCD_INITIAL_CLUSTER=&quot;default=http://localhost:2380&quot;#ETCD_INITIAL_CLUSTER=&quot;${HOST}&quot;#&#39;g}function node2{#Configure the node2 etcd filesed -i &#39;s#\#ETCD_LISTEN_PEER_URLS=&quot;http://localhost:2380&quot;#ETCD_LISTEN_PEER_URLS=&quot;http://${IP2}:2380&quot;#g&#39; /etc/etcd/etcd.confsed -i &#39;s#ETCD_LISTEN_CLIENT_URLS=&quot;http://localhost:2379&quot;#ETCD_LISTEN_CLIENT_URLS=&quot;http://0.0.0.0:2379&quot;#g&#39; /etc/etcd/etcd.confsed -i &#39;s#ETCD_ADVERTISE_CLIENT_URLS=&quot;http://localhost:2379&quot;#ETCD_ADVERTISE_CLIENT_URLS=&quot;http://${IP2}:2379&quot;#g&#39; /etc/etcd/etc.confsed -i &#39;s#\#ETCD_INITIAL_CLUSTER=&quot;default=http://localhost:2380&quot;#ETCD_INITIAL_CLUSTER=&quot;${HOST}&quot;#g&#39; /etc/etcd/etc.conf}function start{    systemctl enable etcd    systemctl restart etcd    systemctl status etcd}if [ &quot;$IP&quot;==&quot;$IP1&quot; ];then    node1    startelse    node2    startfi</code></pre><p>look etcd node list</p><pre><code>etcdctl member list</code></pre><p>look etcd node status</p><pre><code>etcdctl  cluster-health</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言&lt;br&gt;Etcd:一个键值存储仓库，主要用于配置共享和服务发现。&lt;br&gt;优点：&lt;br&gt;    简单：支持 curl 方式的用户 API (HTTP+JSON)&lt;br&gt;    安全：可选 SSL 客户端证书认证&lt;br&gt;    快速：单实例可达每秒 1000 次写操作&lt;br&gt;    可靠：使用 Raft 实现分布式&lt;/p&gt;
&lt;p&gt;本文主要阐述集群etcd的部署&lt;br&gt;
    
    </summary>
    
    
      <category term="linux自动化运维" scheme="http://ippai.top/tags/linux%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
      <category term="etcd" scheme="http://ippai.top/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>Add User Script</title>
    <link href="http://ippai.top/2018/04/04/Add-User-Script/"/>
    <id>http://ippai.top/2018/04/04/Add-User-Script/</id>
    <published>2018-04-04T10:39:32.000Z</published>
    <updated>2018-04-09T03:37:11.048Z</updated>
    
    <content type="html"><![CDATA[<p>前言<br>可用于服务器自动添加用户，并发送邮件<br>实现shell自动化建设<br><a id="more"></a></p><pre><code class="+shell">#!/bin/bashpassword=&quot;password&quot;ip=`ifconfig eth1 |grep inet |awk &#39;{printf &quot;IP:&quot;}&#39;&#39;{print $2}&#39;`echo &quot;请输入要创建的用户名：&quot;read usernameecho &quot;您输入的用户名为: $username&quot;egrep &quot;^servergroups&quot; /etc/group &gt;&amp; /dev/nullif [ $? -ne 0 ]then    groupadd servergroupselse    echo &quot;已存在servergroups组&quot;fiegrep &quot;^$username&quot; /etc/passwd &gt;&amp; /dev/nullif [ $? -ne 0 ]then    useradd $username &amp;&amp; \    usermod -aG servergroups $username &amp;&amp; \    echo $username | passwd --stdin $username    chage -d 0 $username    echo &quot;创建 $username 用户成功&quot;    #echo &quot;密码为:$password&quot;    id $username    text=&quot;用户名：$username\n密码为：$username\n$ip\n注意：第一次登陆必须要修改密码!!!!&quot;    echo -e &quot;$text&quot; | mail -s &quot;$username,服务器用户创建成功，请及时修改密码!!&quot; $username@qq.comelse    echo &quot;$username 已存在&quot;    id $usernamefi</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言&lt;br&gt;可用于服务器自动添加用户，并发送邮件&lt;br&gt;实现shell自动化建设&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://ippai.top/tags/linux/"/>
    
      <category term="shell" scheme="http://ippai.top/tags/shell/"/>
    
      <category term="linux自动化运维" scheme="http://ippai.top/tags/linux%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>你好，Oliver</title>
    <link href="http://ippai.top/2018/04/04/%E4%BD%A0%E5%A5%BD%EF%BC%8COliver/"/>
    <id>http://ippai.top/2018/04/04/你好，Oliver/</id>
    <published>2018-04-04T03:57:04.000Z</published>
    <updated>2018-04-09T02:28:04.866Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
